#!/usr/bin/env python

# python2/3 compatibility
from __future__ import print_function

import argparse
import logging
import os
import subprocess
import re
import sys
import stat
import uuid
import datetime

import jinja2 

logging.basicConfig(
    format="%(asctime)s - %(levelname)s -  %(message)s", 
    datefmt="%y-%m-%d %H:%M:%S", 
    level=logging.INFO
)
log = logging.getLogger()

DEFAULT_JOBDIR="/scratch-cbe/users/%s/batch_input" % os.getlogin()
DEFAULT_OUTDIR="/scratch-cbe/users/%s/batch_output" % os.getlogin() 
DEFAULT_PARTITION="c"
CHOICES_PARTITION=["c", "m", "g"]
DEFAULT_WALLTIME="08:00:00"
DEFAULT_THROTTLE=10
DEFAULT_DELAY=60

NTUPLEPATH="/groups/hephy/cms/dietrich.liko/StopsCompressed/nanoTuples"

def main(input, name, jobdir, outdir, throttle, dryrun, **kwargs):

    log.debug("Reading %s ...", input)
    with open(input, 'r') as inp:
        lines = inp.read()

    commands = []
    splits = []
    for match in re.finditer("^\s*([^\#\s][^\#\n]*)(#SPLIT(\d+))?\s*$", lines, re.M):
        commands.append(match.group(1))
        if match.group(3) is None:
            splits.append(1)
        else:
            splits.append(int(match.group(3)))

    commands, splits = filter_commands(commands, splits) 

    log.debug('Found %d commands', len(commands))

    # env variables to transmit
    export=[]
    proxy_file = check_x509_proxy()
    export.append("X509_USER_PROXY=%s" % proxy_file)

    # if there are more env variables
    export=','.join(export)

    src_dir = os.path.dirname(os.path.abspath(__file__))
    tmpl_file = os.path.join(src_dir, 'mysubmit.j2')
    log.debug('Reading template %s ...', tmpl_file)
    with open(tmpl_file, 'r') as tmpl:
        template = jinja2.Template(tmpl.read())

    fid = uuid.uuid4()
    job_file = os.path.join(jobdir,'%s-%s.sh' % (name, fid) )
    log.info('Writing job file %s', job_file)
    with open(job_file, 'w') as job:
        print(
            template.render(
                name=name,
                first = 0,
                last = sum(splits)-1,
                throttle=throttle,
                outdir=outdir,
                cmds=zip(commands, splits),
                cwd=os.getcwd(),
                export=export,
                **kwargs
            ),
            file=job,
        )
    
    if dryrun:
        sys.exit()

    output = subprocess.check_output( ["sbatch", job_file])
    log.info(output)
    match = re.search('job\s(\d+)', output)
    if not match:
        print('Jobid not found ...')
        sys.exit()

    with open('mysubmit.log','a') as joblog:
        print( "%s,%s,%s" % (match.group(1), name, fid), file=joblog )

def getarg(cmd_array, arg):

    try:
        idx = cmd_array.index(arg)
        return cmd_array[idx+1]
    except ValueError:
        print("Token %s is not in the list %s" % (arg, ' '.join(cmd_array)))
        sys.exit()


def filter_commands(commands, splits):

    new_commands = []
    new_splits = []
    for command, split in zip(commands, splits):
        cmd_array = command.split()
        sample = getarg(cmd_array, '--sample')
        era = getarg(cmd_array, '--processingEra')
        skim = getarg(cmd_array, '--skim')
        dir = os.path.join(NTUPLEPATH, era, skim, sample)
        missing = []
        if split == 1:
            path = os.path.join(dir, '%s.root' % sample)
            if not os.path.exists(path):
                missing.append(0)
        else:
            for i in range(split):
                path = os.path.join(dir, '%s_%d.root' % (sample, i))
                if not os.path.exists(path):
                    missing.append(i)

        if not missing:
            continue

        if len(missing) == split:
            new_commands.append(command)
            new_splits.append(split)
        else:
            for j in missing:
                new_commands.append('%s --nJobs %d --job %d' % (command, split, j))
                new_splits.append(1)

    return new_commands, new_splits

def check_x509_proxy():

    privdir = check_privdir()
    proxy_file = os.path.join(privdir, "x509_proxy")
    log.debug('X509 Proxy File at %s', proxy_file)
    if os.path.exists(proxy_file):
        try:
            timeleft = int(subprocess.check_output(['voms-proxy-info','-timeleft','--file', proxy_file]).strip())
        except:
            timeleft = 0
    else:
        timeleft = 0
    # ask for at least 100 hours
    if timeleft < 360000:
        try:
            subprocess.check_call(['voms-proxy-init', '--rfc', '--voms', 'cms', '--valid', '192:00', '--out', proxy_file])
        except Exception as e:
            log.fatal('Error from voms-proxy-init', e)
            sys.exit()
    
    return proxy_file

def check_privdir():

    privdir = os.path.expanduser("~/private")
    if not os.path.exists(privdir):
        log.debug("Creating private dir %s", privdir)
        os.mkdir(privdir)
    if stat.S_IMODE(os.stat(privdir).st_mode) != 0o700:
        log.debug("Protecting private dir %s", privdir)
        os.chmod(privdir,0o700)

    return privdir

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument("input", metavar="INPUT", help="Input File with job definitions")
    parser.add_argument("-v", "--verbose", action="store_true", default=False, help="Verbose output")
    parser.add_argument("-x", "--dryrun", action="store_true", default=False, help="Do not submit jobs")
    parser.add_argument("-N", "--name", default=None, help="Batch job name (default input filename)")
    parser.add_argument(
        "-j", "--jobdir", metavar="DIR", default=DEFAULT_JOBDIR, 
        help="Directory for job files (default: %s)" %  DEFAULT_JOBDIR 
    )
    parser.add_argument(
        "-o", "--output", metavar="DIR", default=DEFAULT_OUTDIR, 
        help="Directory for output files (default: %s)" %  DEFAULT_OUTDIR 
    )
    parser.add_argument(
        "--partition", dest="partition", default=DEFAULT_PARTITION, choices=CHOICES_PARTITION, 
        help="Partition for batch job (default: %s)" % DEFAULT_PARTITION
    )
    parser.add_argument("--ncpus", type=int, default=None, help="Number of CPUs (cores) per task (default 1)") 
    parser.add_argument("--memory", type=int, default=None, help="memory in GB/core (default 4)") 
    parser.add_argument("--walltime", default=DEFAULT_WALLTIME, help="Walltime of jobs (default %s)" % DEFAULT_WALLTIME) 
    parser.add_argument("-T", "--throttle", default=10, help="Limit number of jobs executing parallel (default 10)")

    args = parser.parse_args()

    if args.verbose:
        log.setLevel(logging.DEBUG)

    input = os.path.realpath(args.input)
    if not os.path.exists(input):
        log.fatal("Input file %s does not exists.", input)
        sys.exit(1)

    if args.name is None:
        name, _ext = os.path.splitext(os.path.basename(input))
    else:
        name = args.name

    jobdir = os.path.realpath(args.jobdir)
    if not os.path.exists(jobdir):
        os.makedirs(jobdir)

    outdir = os.path.realpath(args.output)
    if not os.path.exists(outdir):
        os.makedirs(outdir)

    main(input, name, jobdir, outdir, args.throttle, args.dryrun,
        partition=args.partition, 
        ncpus=args.ncpus, 
        memory=args.memory, 
        walltime=args.walltime)
